# SPDX-FileCopyrightText: 2025 NORCE Research AS
# SPDX-License-Identifier: GPL-3.0
# pylint: disable=C0302,R0914,R1702,R0912,R0915,E1102

"""
Utiliy script for creating a deck with projected pressures from given
regional and site decks.
"""

import os
import csv
from alive_progress import alive_bar
import numpy as np
import pandas as pd
from shapely.geometry import LineString, Polygon, Point
from scipy.interpolate import LinearNDInterpolator, interp1d
from resdata.grid import Grid
from resdata.resfile import ResdataFile
from expreccs.utils.writefile import compact_format


def create_deck(dic):
    """
    Create a deck from given reg and site decks with projected pressures

    Args:
        dic (dict): Global dictionary

    Returns:
        dic (dict): Modified global dictionary

    """
    if dic["zones"]:
        dic["explicit"] = False
    case = f"{dic['freg']}/{dic['reg']}"
    rst = case + ".UNRST"
    grid = case + ".EGRID"
    init = case + ".INIT"
    dic["rrst"], dic["rgrid"] = ResdataFile(rst), Grid(grid)
    dic["rinit"] = ResdataFile(init)
    case = f"{dic['fsit']}/{dic['sit']}"
    rst = case + ".UNRST"
    grid = case + ".EGRID"
    init = case + ".INIT"
    dic["sdata"] = case + ".DATA"
    dic["srst"], dic["sgrid"], dic["sinit"] = (
        ResdataFile(rst),
        Grid(grid),
        ResdataFile(init),
    )
    dic["rfip"] = [1] * (dic["rgrid"].nx * dic["rgrid"].ny * dic["rgrid"].nz)
    dic["sfip"] = [1] * (dic["sgrid"].nx * dic["sgrid"].ny * dic["sgrid"].nz)
    dic["ufip"] = [1]
    if dic["zones"]:
        dic["rfip"] = np.array(dic["rinit"].iget_kw("FIPNUM")[0])
        dic["sfip"] = np.array(dic["sinit"].iget_kw("FIPNUM")[0])
        dic["ufip"] = np.intersect1d(np.unique(dic["rfip"]), np.unique(dic["sfip"]))
    for n in ["r", "s"]:
        dic[f"{n}days"] = []
        for i in range(dic[f"{n}rst"].num_report_steps()):
            dic[f"{n}days"].append(dic[f"{n}rst"].iget_kw("DOUBHEAD")[i][0])
        dic[f"{n}days"] = np.array(dic[f"{n}days"])
    dic["isdays"] = dic[f"{n}days"].copy()
    if len(dic["freq"]) < len(dic["isdays"]) - 2:
        dic["freq"] = np.array([int(dic["freq"][0])] * (len(dic["isdays"]) - 1))
    else:
        dic["freq"] = np.array([int(val) for val in dic["freq"]])
    if len(dic["acoeff"]) < len(dic["isdays"]) - 2:
        dic["acoeff"] = np.array([float(dic["acoeff"][0])] * (len(dic["isdays"]) - 1))
    else:
        dic["acoeff"] = np.array([float(val) for val in dic["acoeff"]])
    if max(dic["freq"]) <= 0:
        dic["sdays"] = []
    dic["sopn"] = ["0"] * (dic["sgrid"].nx * dic["sgrid"].ny * dic["sgrid"].nz)
    if not os.path.exists(f"{dic['fol']}"):
        os.system(f"mkdir {dic['fol']}")
    if not os.path.exists(f"{dic['fol']}/bc") and max(dic["freq"]) > 0:
        os.system(f"mkdir {dic['fol']}/bc")
    find_ij_orientation(dic)
    if dic["nonregular"]:
        start_point, dic["sbound"], grid = [], [], []
        actnum = np.array(dic["sinit"].iget_kw("PORV")[0]) > 0
        if dic["sgrid"].nz == 1:
            grid = actnum
        else:
            for j in range(dic["sgrid"].ny):
                for i in range(dic["sgrid"].nx):
                    grid.append(0)
                    for k in range(dic["sgrid"].nz):
                        ind = (
                            i
                            + j * dic["sgrid"].nx
                            + k * dic["sgrid"].nx * dic["sgrid"].ny
                        )
                        if actnum[ind] > 0:
                            grid[-1] = 1
                            break
        grid = np.array(grid).reshape(dic["sgrid"].ny, dic["sgrid"].nx)
        for j in range(dic["sgrid"].ny):
            for i in range(dic["sgrid"].nx):
                if grid[j][i]:
                    start_point = [j, i]
                    break
            if start_point:
                break
        boundary, dire = site_contour(grid, start_point)
        boundary = np.array(boundary)
        dic["sopn"] = [
            "0" for _ in range(dic["sgrid"].nx * dic["sgrid"].ny * dic["sgrid"].nz)
        ]
        coords = get_bccon(dic, boundary, dire)
        dic["oprn"] = [
            "0" for _ in range(dic["rgrid"].nx * dic["rgrid"].ny * dic["rgrid"].nz)
        ]
        x_i, y_i, z_i, inds, fipr, offset = get_xymaps(dic, coords)
        git = "--This file was generated by expreccs https://github.com/cssr-tools/expreccs\n"
        dic["oprn"] = compact_format(dic["oprn"])
        dic["oprn"].insert(0, "OPERNUM\n")
        dic["oprn"].insert(0, git)
        dic["oprn"].insert(0, "--Copyright (C) 2025 NORCE Research AS\n")
        dic["oprn"].append("/")
        with open(
            f"{dic['freg']}/OPERNUM_EXPRECCS.INC",
            "w",
            encoding="utf8",
        ) as file:
            file.write("".join(dic["oprn"]))
        dic["rp"] = [[] for _ in range(dic["rrst"].num_report_steps())]
        tmp = dic["sbound"].copy()
        if dic["sbound"]:
            print("Dynamic interpolator:")
        with alive_bar(dic["rrst"].num_report_steps()) as bar_animation:
            for i in range(dic["rrst"].num_report_steps()):
                if not dic["sbound"]:
                    break
                bar_animation()
                z_p = np.array(dic["rrst"].iget_kw("PRESSURE")[i])
                if not dic["explicit"]:
                    z_p -= np.array(dic["rrst"].iget_kw("PRESSURE")[0])
                    z_p = np.array([z_p[ind] for ind in inds])
                else:
                    if dic["rinit"].has_kw("WAT_DEN"):
                        den = 9.81 * dic["rinit"].iget_kw("WAT_DEN")[i] / 1e5
                    else:
                        den = (
                            9.81
                            * 1000.0
                            * (np.array(dic["rrst"].iget_kw("PRESSURE")[0]) > 0)
                            / 1e5
                        )
                    z_p = np.array(
                        [z_p[ind] + den[ind] * offset[j] for j, ind in enumerate(inds)]
                    )
                count, n = 0, -1
                interp = LinearNDInterpolator(list(zip(x_i, y_i, z_i)), z_p)
                for x, y, z in coords:
                    if i == 0:
                        edit = dic["sbound"][count].split()
                    else:
                        edit = tmp[count].split()
                    if dic["zones"]:
                        if n != dic["ksfips"][int(edit[5]) - 1]:
                            n = dic["ksfips"][int(edit[5]) - 1]
                            whr = fipr == n
                            if sum(whr) > 0:
                                interp = LinearNDInterpolator(
                                    list(zip(x_i[whr], y_i[whr], z_i[whr])), z_p[whr]
                                )
                        if sum(whr) == 0:
                            if i == 0:
                                dic["sopn"][
                                    dic["sgrid"].get_global_index(
                                        ijk=(
                                            int(edit[1]) - 1,
                                            int(edit[3]) - 1,
                                            int(edit[5]) - 1,
                                        )
                                    )
                                ] = "-1"
                                dic["sbound"].pop(count)
                                if not dic["explicit"]:
                                    dic["spres"].pop(count)
                        else:
                            d_z = 0
                            if dic["zones"]:
                                d_z = np.round(dic["rtmin"] - dic["stmin"], 2)
                            if not np.isnan(interp((x, y, z + d_z))):
                                count += 1
                                dic["rp"][i].append([count, interp((x, y, z + d_z))])
                                if i == 0:
                                    edit[0] = str(count)
                                    dic["sbound"][count - 1] = " ".join(edit)
                            else:
                                if i == 0:
                                    dic["sopn"][
                                        dic["sgrid"].get_global_index(
                                            ijk=(
                                                int(edit[1]) - 1,
                                                int(edit[3]) - 1,
                                                int(edit[5]) - 1,
                                            )
                                        )
                                    ] = "-1"
                                    dic["sbound"].pop(count)
                                    if not dic["explicit"]:
                                        dic["spres"].pop(count)
                    else:
                        if not np.isnan(interp((x, y, z))):
                            count += 1
                            dic["rp"][i].append([count, interp((x, y, z))])
                            if i == 0:
                                edit[0] = str(count)
                                dic["sbound"][count - 1] = " ".join(edit)
                        else:
                            if i == 0:
                                dic["sopn"][
                                    dic["sgrid"].get_global_index(
                                        ijk=(
                                            int(edit[1]) - 1,
                                            int(edit[3]) - 1,
                                            int(edit[5]) - 1,
                                        )
                                    )
                                ] = "-1"
                                dic["sbound"].pop(count)
                                if not dic["explicit"]:
                                    dic["spres"].pop(count)
    else:
        dic["gc"] = 0
        dic["snum"], dic["fipn"], dic["sbound"], dic["sai"] = [], [], [], []
        dic["rbound"], dic["rcoord"], dic["sdel"], dic["oprn"] = [], [], [], []
        for i in ["x", "y", "z", "f", "t"]:
            dic[f"s{i}s"], dic[f"s{i}e"], dic[f"s{i}n"], dic[f"s{i}w"] = [], [], [], []
        extract_site_borders(dic)
        find_regional_cells(dic)
        dynamic_interpolator(dic)
    temporal_interpolation(dic)
    write_files(dic)


def get_xymaps(dic, coords):
    """
    Process the spatial maps of the boundary cells

    Args:
        dic (dict): Global dictionary\n
        coords (list): xy coordinates of the site boundaries

    Returns:
        x (array): x coordinates of the site boundaries\n
        y (array): y coordinates of the site boundaries\n
        z (array): z coordinates of the site boundaries\n
        inds (list): Active indices of the boundaries\n
        fipr (arrays): Number of fipnum\n
        offset (list): Offset fot the hydrostaic pressure

    """
    x, y, z, c_x, c_y, c_z = [], [], [], [], [], []
    fipr, x_i, y_i, z_i, inds, offset = [], [], [], [], [], []
    dic["rtmin"] = np.inf
    for cell in dic["rgrid"]:
        x.append(cell.coordinate[0])
        y.append(cell.coordinate[1])
        z.append(cell.coordinate[2])
        if cell.active:
            c_x.append(cell.coordinate[0])
            c_y.append(cell.coordinate[1])
            c_z.append(cell.coordinate[2])
    c_x = np.array(c_x)
    c_y = np.array(c_y)
    c_z = np.array(c_z)
    dz = 0.5 * np.array(dic["rinit"].iget_kw("DZ")[0])
    act = np.array(dic["rinit"].iget_kw("PORV")[0]) > 0
    for coord in coords:
        aind = int(
            np.argmin(abs(c_x - coord[0]) + abs(c_y - coord[1]) + abs(c_z - coord[2]))
        )
        ind = dic["rgrid"].get_global_index(active_index=aind)
        ijk = dic["rgrid"].get_ijk(active_index=aind)
        if not act[ind] or (dic["zones"] and dic["rfip"][aind] not in dic["ufip"]):
            continue
        take = [False, False, False, False, False]
        if aind not in inds:
            take[0] = True
            x_i.append(x[ind])
            y_i.append(y[ind])
            z_i.append(z[ind] - dz[aind])
            offset.append(-dz[aind])
            inds.append(aind)
            fipr.append(dic["rfip"][aind])
            dic["oprn"][ind] = "1"
        if ijk[0] < dic["rgrid"].nx - 1:
            tmp = dic["rgrid"].get_active_index(global_index=ind + 1)
            if tmp not in inds:
                take[1] = True
                dic["oprn"][ind + 1] = "1"
                x_i.append(x[ind + 1])
                y_i.append(y[ind + 1])
                z_i.append(z[ind + 1] - dz[tmp])
                offset.append(-dz[tmp])
                inds.append(tmp)
                fipr.append(dic["rfip"][tmp])
        if 0 < ijk[0]:
            tmp = dic["rgrid"].get_active_index(global_index=ind - 1)
            if tmp not in inds:
                take[2] = True
                dic["oprn"][ind - 1] = "1"
                x_i.append(x[ind - 1])
                y_i.append(y[ind - 1])
                z_i.append(z[ind - 1] - dz[tmp])
                offset.append(-dz[tmp])
                inds.append(tmp)
                fipr.append(dic["rfip"][tmp])
        if 0 < ijk[1]:
            tmp = dic["rgrid"].get_active_index(global_index=ind - dic["rgrid"].nx)
            if tmp not in inds:
                take[3] = True
                dic["oprn"][ind - dic["rgrid"].nx] = "1"
                x_i.append(x[ind - dic["rgrid"].nx])
                y_i.append(y[ind - dic["rgrid"].nx])
                z_i.append(z[ind - dic["rgrid"].nx] - dz[tmp])
                offset.append(-dz[tmp])
                inds.append(tmp)
                fipr.append(dic["rfip"][tmp])
        if ijk[1] < dic["rgrid"].ny - 1:
            tmp = dic["rgrid"].get_active_index(global_index=ind + dic["rgrid"].nx)
            if tmp not in inds:
                take[4] = True
                dic["oprn"][ind + dic["rgrid"].nx] = "1"
                x_i.append(x[ind + dic["rgrid"].nx])
                y_i.append(y[ind + dic["rgrid"].nx])
                z_i.append(z[ind + dic["rgrid"].nx] - dz[tmp])
                offset.append(-dz[tmp])
                inds.append(tmp)
                fipr.append(dic["rfip"][tmp])
        if take[0]:
            x_i.append(x[ind])
            y_i.append(y[ind])
            z_i.append(z[ind] + dz[aind])
            offset.append(dz[aind])
            inds.append(aind)
            fipr.append(dic["rfip"][aind])
        if take[1]:
            tmp = dic["rgrid"].get_active_index(global_index=ind + 1)
            x_i.append(x[ind + 1])
            y_i.append(y[ind + 1])
            z_i.append(z[ind + 1] + dz[tmp])
            offset.append(dz[tmp])
            inds.append(tmp)
            fipr.append(dic["rfip"][tmp])
        if take[2]:
            tmp = dic["rgrid"].get_active_index(global_index=ind - 1)
            x_i.append(x[ind - 1])
            y_i.append(y[ind - 1])
            z_i.append(z[ind - 1] + dz[tmp])
            offset.append(dz[tmp])
            inds.append(tmp)
            fipr.append(dic["rfip"][tmp])
        if take[3]:
            x_i.append(x[ind - dic["rgrid"].nx])
            y_i.append(y[ind - dic["rgrid"].nx])
            z_i.append(z[ind - dic["rgrid"].nx] + dz[tmp])
            offset.append(dz[tmp])
            inds.append(tmp)
            fipr.append(dic["rfip"][tmp])
        if take[4]:
            tmp = dic["rgrid"].get_active_index(global_index=ind + dic["rgrid"].nx)
            x_i.append(x[ind + dic["rgrid"].nx])
            y_i.append(y[ind + dic["rgrid"].nx])
            z_i.append(z[ind + dic["rgrid"].nx] + dz[tmp])
            offset.append(dz[tmp])
            inds.append(tmp)
            fipr.append(dic["rfip"][tmp])
    if dic["zones"] and z_i:
        dic["rtmin"] = min(z_i)
    return np.array(x_i), np.array(y_i), np.array(z_i), inds, np.array(fipr), offset


def get_bccon(dic, boundary, dire):
    """
    Process the regional and site grid coordinates

    Args:
        dic (dict): Global dictionary\n
        boundary (list): Modified global dictionary\n
        dire (list): Direction of the bc connection

    Returns:
        coords (list): xy coordinates of the site boundaries\n
        dic (dict): Modify global dictionary

    """
    coords, dic["spres"], dic["krfips"], dic["ksfips"] = [], [], [], []
    dic["stmin"] = np.inf
    act = np.array(dic["sinit"].iget_kw("PORV")[0]) > 0
    dx, dy, dz = 1.0 * act, 1.0 * act, 1.0 * act
    dx[act] = dic["sinit"].iget_kw("DX")[0]
    dy[act] = dic["sinit"].iget_kw("DY")[0]
    dz[act] = dic["sinit"].iget_kw("DZ")[0]
    for k in range(dic["sgrid"].nz):
        for i, val in enumerate(boundary):
            ind = int(
                val[0] * dic["sgrid"].nx
                + val[1]
                + k * dic["sgrid"].nx * dic["sgrid"].ny
            )
            if not act[ind]:
                continue
            if (
                dire[i] == 1
                and dic["boundaries"][2] == -1
                and val[0] == dic["sgrid"].ny - 1
            ):
                continue
            if dire[i] == 2 and dic["boundaries"][3] == -1 and val[1] == 0:
                continue
            if dire[i] == 3 and dic["boundaries"][0] == -1 and val[0] == 0:
                continue
            if (
                dire[i] == 4
                and dic["boundaries"][1] == -1
                and val[1] == dic["sgrid"].nx - 1
            ):
                continue
            dic["sopn"][ind] = str(dire[i])
            if k == 0:
                dic["stmin"] = min(
                    dic["stmin"], dic["sgrid"][ind].coordinate[2] - 0.5 * dz[ind]
                )
            if dire[i] == 1:
                coords.append(
                    [
                        dic["sgrid"][ind].coordinate[0],
                        dic["sgrid"][ind].coordinate[1] + 0.5 * dy[ind],
                        dic["sgrid"][ind].coordinate[2],
                    ]
                )
                dic["sbound"].append(
                    f"{i + 1} {val[1] + 1} {val[1] + 1} {val[0] + 1} "
                    f"{val[0] + 1} {k + 1} {k + 1} 'J' /"
                )
            elif dire[i] == 2:
                coords.append(
                    [
                        dic["sgrid"][ind].coordinate[0] - 0.5 * dx[ind],
                        dic["sgrid"][ind].coordinate[1],
                        dic["sgrid"][ind].coordinate[2],
                    ]
                )
                dic["sbound"].append(
                    f"{i + 1} {val[1] + 1} {val[1] + 1} {val[0] + 1} "
                    f"{val[0] + 1} {k + 1} {k + 1} 'I-' /"
                )
            elif dire[i] == 3:
                coords.append(
                    [
                        dic["sgrid"][ind].coordinate[0],
                        dic["sgrid"][ind].coordinate[1] - 0.5 * dy[ind],
                        dic["sgrid"][ind].coordinate[2],
                    ]
                )
                dic["sbound"].append(
                    f"{i + 1} {val[1] + 1} {val[1] + 1} {val[0] + 1} "
                    f"{val[0] + 1} {k + 1} {k + 1} 'J-' /"
                )
            elif dire[i] == 4:
                coords.append(
                    [
                        dic["sgrid"][ind].coordinate[0] + 0.5 * dx[ind],
                        dic["sgrid"][ind].coordinate[1],
                        dic["sgrid"][ind].coordinate[2],
                    ]
                )
                dic["sbound"].append(
                    f"{i + 1} {val[1] + 1} {val[1] + 1} {val[0] + 1} "
                    f"{val[0] + 1} {k + 1} {k + 1} 'I' /"
                )
            if not dic["explicit"]:
                ind = dic["sgrid"].get_active_index(global_index=ind)
                dic["spres"].append(dic["srst"].iget_kw("PRESSURE")[0][ind])
    if not dic["explicit"]:
        for n in ["r", "s"]:
            act = np.array(dic[f"{n}init"].iget_kw("PORV")[0]) > 0
            for k in range(dic[f"{n}grid"].nz):
                for j in range(dic[f"{n}grid"].ny):
                    for i in range(dic[f"{n}grid"].nx):
                        ind = (
                            i
                            + j * dic[f"{n}grid"].nx
                            + k * dic[f"{n}grid"].nx * dic[f"{n}grid"].ny
                        )
                        inda = dic[f"{n}grid"].get_active_index(global_index=ind)
                        if act[ind] and len(dic[f"k{n}fips"]) == k:
                            dic[f"k{n}fips"].append(dic[f"{n}fip"][inda])
                            break
                    if len(dic[f"k{n}fips"]) == k + 1:
                        break
                if len(dic[f"k{n}fips"]) == k:
                    dic[f"k{n}fips"].append(-1)
    return coords


def site_contour(grid, start):
    """
    Process the site contour

    Args:
        grid (array): Binary map of the active cells in the grid\n
        start (array): Initial coordinates in the conrour

    Returns:
        boundary (list): Modified global dictionary\n
        dir (list): Direction of the bc connection

    """
    directions = [(-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1)]
    boundary, dire = [], []
    current = start
    backtrack_dir = 7
    start_backtrack = backtrack_dir
    first = True
    while True:
        boundary.append(current)
        found = False
        for i in range(8):
            dir_idx = (backtrack_dir + 1 + i) % 8
            dr, dc = directions[dir_idx]
            nr, nc = current[0] + dr, current[1] + dc
            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc]:
                if len(boundary) == 1:
                    if current[0] == 0:
                        dire.append(2)
                    elif not grid[current[0] - 1][current[1]]:
                        dire.append(2)
                    elif current[0] == len(grid[0]):
                        dire.append(4)
                    elif not grid[current[0] + 1][current[1]]:
                        dire.append(4)
                    elif current[1] == 0:
                        dire.append(3)
                    elif not grid[current[0]][current[1] - 1]:
                        dire.append(3)
                    elif current[1] == len(grid):
                        dire.append(1)
                    elif not grid[current[0]][current[1] + 1]:
                        dire.append(1)
                current = [nr, nc]
                backtrack_dir = (dir_idx + 6) % 8
                if dir_idx in [0, 7]:
                    dire.append(1)
                elif dir_idx in [1, 2]:
                    dire.append(2)
                elif dir_idx in [3, 4]:
                    dire.append(3)
                elif dir_idx in [5, 6]:
                    dire.append(4)
                found = True
                break
        if not found:
            break
        if current == start and backtrack_dir == start_backtrack and not first:
            break
        first = False
    return boundary, dire


def handle_grid_coord(dic):
    """
    Process the regional and site grid coordinates

    Args:
        dic (dict): Global dictionary

    Returns:
        dic (dict): Modified global dictionary

    """
    dic["sbox"] = dic["sgrid"].get_bounding_box_2d()
    dic["sbox"] += (dic["sbox"][0],)
    c_x, c_y, c_z = [], [], []
    s_x, s_y = [], []
    poly = Polygon(
        [
            (dic["sbox"][0][0], dic["sbox"][0][1]),
            (dic["sbox"][1][0], dic["sbox"][1][1]),
            (dic["sbox"][2][0], dic["sbox"][2][1]),
            (dic["sbox"][3][0], dic["sbox"][3][1]),
        ]
    )
    ijn = dic["sgrid"].nx * dic["sgrid"].ny - 1
    for n, cell in enumerate(dic["sgrid"]):
        if cell.active:
            s_x.append(cell.coordinate[0])
            s_y.append(cell.coordinate[1])
        if n == ijn:
            break
    s_x = np.array(s_x)
    s_y = np.array(s_y)
    for cell in dic["rgrid"]:
        if cell.active:
            c_x.append(cell.coordinate[0])
            c_y.append(cell.coordinate[1])
            c_z.append(cell.coordinate[2])
            point = Point(cell.coordinate[0], cell.coordinate[1])
            if poly.contains(point):
                ind = pd.Series(abs(c_x[-1] - s_x) + abs(c_y[-1] - s_y)).argmin()
                ijk = dic["sgrid"].get_ijk(active_index=ind)
                z_t = dic["sgrid"].get_xyz(ijk=ijk)[2]
                z_b = dic["sgrid"].get_xyz(
                    ijk=(ijk[0], ijk[1], ijk[2] + dic["sgrid"].nz - 1)
                )[2]
                d_z = 0.5 * dic["sgrid"].cell_dz(ijk=ijk)
                dic["fipn"].append(f"{cell.k+2}")
                if (
                    c_z[-1] + 0.5 * cell.dz >= z_t - d_z
                    and c_z[-1] - 0.5 * cell.dz <= z_b + d_z
                ):
                    dic["oprn"].append("1")
                else:
                    dic["oprn"].append("7")
            else:
                dic["oprn"].append("8")
                dic["fipn"].append("1")
        else:
            dic["oprn"].append("8")
            dic["fipn"].append("1")
    dic["c_x"] = np.array(c_x)
    dic["c_y"] = np.array(c_y)
    dic["c_z"] = np.array(c_z)
    dic["rnxy"] = dic["rgrid"].nx * dic["rgrid"].ny
    dic["rnxyz"] = dic["rgrid"].nx * dic["rgrid"].ny * dic["rgrid"].nz


def check_regional_neighbours(dic, gind, p, n, d_z):
    """
    Add to the interpolator neighbouring regional cells

    Args:
        dic (dict): Global dictionary\n
        gind (int): Global cell index\n
        p (str): Cardinal direction\n
        n (int): Side number\n
        d_z (float): Thickness regional cell

    Returns:
        dic (dict): Modified global dictionary

    """
    ijk = dic["rgrid"].get_ijk(global_index=gind)
    if dic["rgrid"].nz > 1:
        noise = -1e-4 * np.random.rand()
    else:
        noise = 0
    if ijk[1] - 1 >= 0:
        if dic["rgrid"].get_active_index(
            global_index=gind - dic["rgrid"].nx
        ) not in dic[f"ri{p}"] and dic["rgrid"].active(
            global_index=gind - dic["rgrid"].nx
        ):
            dic[f"rx{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind - dic["rgrid"].nx)[0]
            )
            dic[f"ry{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind - dic["rgrid"].nx)[1]
            )
            dic[f"rz{p}"].append(
                noise + dic["rgrid"].get_xyz(global_index=gind - dic["rgrid"].nx)[2]
            )
            dic[f"ri{p}"].append(
                dic["rgrid"].get_active_index(global_index=gind - dic["rgrid"].nx)
            )
            dic[f"rk{p}"].append(ijk[2])
            dic[f"rf{p}"].append(
                dic["rfip"][
                    dic["rgrid"].get_active_index(global_index=gind - dic["rgrid"].nx)
                ]
            )
            dic[f"rt{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind - dic["rgrid"].nx)[2]
                - d_z[
                    dic["rgrid"].get_active_index(global_index=gind - dic["rgrid"].nx)
                ]
            )
            dic["oprn"][
                gind - dic["rgrid"].nx
            ] = f"{2+n if int(dic['oprn'][gind-dic['rgrid'].nx])==2+n else 6}"
    if ijk[1] + 1 < dic["rgrid"].ny:
        if dic["rgrid"].get_active_index(
            global_index=gind + dic["rgrid"].nx
        ) not in dic[f"ri{p}"] and dic["rgrid"].active(
            global_index=gind + dic["rgrid"].nx
        ):
            dic[f"rx{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind + dic["rgrid"].nx)[0]
            )
            dic[f"ry{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind + dic["rgrid"].nx)[1]
            )
            dic[f"rz{p}"].append(
                noise + dic["rgrid"].get_xyz(global_index=gind + dic["rgrid"].nx)[2]
            )
            dic[f"ri{p}"].append(
                dic["rgrid"].get_active_index(global_index=gind + dic["rgrid"].nx)
            )
            dic[f"rk{p}"].append(ijk[2])
            dic[f"rf{p}"].append(
                dic["rfip"][
                    dic["rgrid"].get_active_index(global_index=gind + dic["rgrid"].nx)
                ]
            )
            dic[f"rt{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind + dic["rgrid"].nx)[2]
                - d_z[
                    dic["rgrid"].get_active_index(global_index=gind + dic["rgrid"].nx)
                ]
            )
            dic["oprn"][
                gind + dic["rgrid"].nx
            ] = f"{2+n if int(dic['oprn'][gind+dic['rgrid'].nx])==2+n else 6}"
    if ijk[0] - 1 >= 0:
        if dic["rgrid"].get_active_index(global_index=gind - 1) not in dic[
            f"ri{p}"
        ] and dic["rgrid"].active(global_index=gind - 1):
            dic[f"rx{p}"].append(dic["rgrid"].get_xyz(global_index=gind - 1)[0])
            dic[f"ry{p}"].append(dic["rgrid"].get_xyz(global_index=gind - 1)[1])
            dic[f"rz{p}"].append(noise + dic["rgrid"].get_xyz(global_index=gind - 1)[2])
            dic[f"ri{p}"].append(dic["rgrid"].get_active_index(global_index=gind - 1))
            dic[f"rk{p}"].append(ijk[2])
            dic[f"rf{p}"].append(
                dic["rfip"][dic["rgrid"].get_active_index(global_index=gind - 1)]
            )
            dic[f"rt{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind - 1)[2]
                - d_z[dic["rgrid"].get_active_index(global_index=gind - 1)]
            )
            dic["oprn"][gind - 1] = f"{2+n if int(dic['oprn'][gind-1])==2+n else 6}"
    if ijk[0] + 1 < dic["rgrid"].nx:
        if dic["rgrid"].get_active_index(global_index=gind + 1) not in dic[
            f"ri{p}"
        ] and dic["rgrid"].active(global_index=gind + 1):
            dic[f"rx{p}"].append(dic["rgrid"].get_xyz(global_index=gind + 1)[0])
            dic[f"ry{p}"].append(dic["rgrid"].get_xyz(global_index=gind + 1)[1])
            dic[f"rz{p}"].append(noise + dic["rgrid"].get_xyz(global_index=gind + 1)[2])
            dic[f"ri{p}"].append(dic["rgrid"].get_active_index(global_index=gind + 1))
            dic[f"rk{p}"].append(ijk[2])
            dic[f"rf{p}"].append(
                dic["rfip"][dic["rgrid"].get_active_index(global_index=gind + 1)]
            )
            dic[f"rt{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind + 1)[2]
                - d_z[dic["rgrid"].get_active_index(global_index=gind + 1)]
            )
            dic["oprn"][gind + 1] = f"{2+n if int(dic['oprn'][gind+1])==2+n else 6}"
    if gind - dic["rnxy"] >= 0:
        if dic["rgrid"].get_active_index(global_index=gind - dic["rnxy"]) not in dic[
            f"ri{p}"
        ] and dic["rgrid"].active(global_index=gind - dic["rnxy"]):
            dic[f"rx{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind - dic["rnxy"])[0]
            )
            dic[f"ry{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind - dic["rnxy"])[1]
            )
            dic[f"rz{p}"].append(
                noise + dic["rgrid"].get_xyz(global_index=gind - dic["rnxy"])[2]
            )
            dic[f"ri{p}"].append(
                dic["rgrid"].get_active_index(global_index=gind - dic["rnxy"])
            )
            dic[f"rk{p}"].append(ijk[2] - 1)
            dic[f"rf{p}"].append(
                dic["rfip"][
                    dic["rgrid"].get_active_index(global_index=gind - dic["rnxy"])
                ]
            )
            dic[f"rt{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind - dic["rnxy"])[2]
                - d_z[dic["rgrid"].get_active_index(global_index=gind - dic["rnxy"])]
            )
            dic["oprn"][
                gind - dic["rnxy"]
            ] = f"{2+n if int(dic['oprn'][gind- dic['rnxy']])==2+n else 6}"
    if gind + dic["rnxy"] < dic["rnxy"] * dic["rgrid"].nz:
        if dic["rgrid"].get_active_index(global_index=gind + dic["rnxy"]) not in dic[
            f"ri{p}"
        ] and dic["rgrid"].active(global_index=gind + dic["rnxy"]):
            dic[f"rx{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind + dic["rnxy"])[0]
            )
            dic[f"ry{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind + dic["rnxy"])[1]
            )
            dic[f"rz{p}"].append(
                noise + dic["rgrid"].get_xyz(global_index=gind + dic["rnxy"])[2]
            )
            dic[f"ri{p}"].append(
                dic["rgrid"].get_active_index(global_index=gind + dic["rnxy"])
            )
            dic[f"rk{p}"].append(ijk[2] + 1)
            dic[f"rf{p}"].append(
                dic["rfip"][
                    dic["rgrid"].get_active_index(global_index=gind + dic["rnxy"])
                ]
            )
            dic[f"rt{p}"].append(
                dic["rgrid"].get_xyz(global_index=gind + dic["rnxy"])[2]
                - d_z[dic["rgrid"].get_active_index(global_index=gind + dic["rnxy"])]
            )
            dic["oprn"][
                gind + dic["rnxy"]
            ] = f"{2+n if int(dic['oprn'][gind+ dic['rnxy']])==2+n else 6}"


def check_intersection(dic, ind, gind, i, n):
    """
    Check if there are nnc in the regional/site overlapping

    Args:
        dic (dict): Global dictionary\n
        ind (int): Index for the closest cell\n
        gind (int): Global cell index in the regional model\n
        i (int): Position of the x, y, or z coords\n
        n (int): Position for the cardinal direction

    Returns:
        lines (list): Horizontal and vertical lines in the regional model

    """
    if i > [dic["sgrid"].nx, dic["sgrid"].ny, dic["sgrid"].nx, dic["sgrid"].nx][n]:
        lift = -1e-4
    else:
        lift = 1e-4
    dic[f"rkg{['n', 'w', 's', 'e'][n]}"].append(
        (dic["rgrid"].get_xyz(active_index=ind)[2] + lift, ind)
    )
    lines = []
    for shift in [dic["rgrid"].nx, 1]:
        x_l, y_l, x_p, y_p = 0, 0, 0, 0
        l_p = [0, 0]
        x_m = dic["rgrid"].get_xyz(active_index=ind)[0]
        y_m = dic["rgrid"].get_xyz(active_index=ind)[1]
        if gind - shift >= 0:
            if dic["rgrid"].active(global_index=gind - shift):
                x_l = dic["rgrid"].get_xyz(global_index=gind - shift)[0]
                y_l = dic["rgrid"].get_xyz(global_index=gind - shift)[1]
                l_p[0] = 1
        if gind + shift < dic["rnxyz"]:
            if dic["rgrid"].active(global_index=gind + shift):
                x_p = dic["rgrid"].get_xyz(global_index=gind + shift)[0]
                y_p = dic["rgrid"].get_xyz(global_index=gind + shift)[1]
                l_p[1] = 1
        if sum(l_p) == 2:
            xy = [x_l, y_l, x_p, y_p]
            lines.append(LineString([(xy[0], xy[1]), (xy[2], xy[3])]))
        elif l_p[1] == 1:
            xy = [x_m, y_m, x_p, y_p]
            lines.append(LineString([(xy[0], xy[1]), (xy[2], xy[3])]))
        elif l_p[0] == 1:
            xy = [x_l, y_l, x_m, y_m]
            lines.append(LineString([(xy[0], xy[1]), (xy[2], xy[3])]))
        else:
            lines.append(0)
    return lines


def find_regional_cells(dic):
    """
    Find the cells to build the interpolator

    Args:
        dic (dict): Global dictionary

    Returns:
        dic (dict): Modified global dictionary

    """
    handle_grid_coord(dic)
    count = -1
    d_z = 0.5 * dic["rinit"].iget_kw("DZ")[0]
    whr = [True] * len(dic["c_y"])
    ntot = 0
    for n, p in enumerate(
        ["n", "w", "s", "e"],
    ):
        for i, (x_c, y_c, z_c) in enumerate(
            zip(dic[f"sx{p}"], dic[f"sy{p}"], dic[f"sz{p}"])
        ):
            ntot += 1
    print("\nFind the regional cells to build the interpolator:")
    with alive_bar(ntot) as bar_animation:
        for n, p in enumerate(
            ["n", "w", "s", "e"],
        ):
            (
                dic[f"rx{p}"],
                dic[f"ry{p}"],
                dic[f"rz{p}"],
                dic[f"ri{p}"],
                dic[f"sd{p}"],
                dic[f"rf{p}"],
                dic[f"rt{p}"],
                dic[f"rk{p}"],
                dic[f"rkg{p}"],
            ) = (
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
            )
            fin = 0
            for i, (x_c, y_c, z_c) in enumerate(
                zip(dic[f"sx{p}"], dic[f"sy{p}"], dic[f"sz{p}"])
            ):
                bar_animation()
                if dic["zones"]:
                    if fin != dic[f"sf{p}"][i]:
                        fin = dic[f"sf{p}"][i]
                        whr = dic["rfip"] != fin
                        c_x, c_y, c_z = (
                            dic["c_x"].copy(),
                            dic["c_y"].copy(),
                            dic["c_z"].copy(),
                        )
                        c_x[whr], c_y[whr], c_z[whr] = np.inf, np.inf, np.inf
                    ind = pd.Series(
                        (abs(c_x - x_c) + abs(c_y - y_c) + abs(c_z - z_c))
                    ).argmin()
                else:
                    ind = pd.Series(
                        (
                            abs(dic["c_x"] - x_c)
                            + abs(dic["c_y"] - y_c)
                            + abs(dic["c_z"] - z_c)
                        )
                    ).argmin()
                count += 1
                gind = dic["rgrid"].global_index(ind)
                lines = check_intersection(dic, ind, gind, i, n)
                if lines[0] == 0 and lines[1] == 0:
                    dic["sdel"].append(count)
                    dic[f"sd{p}"].append(i)
                    continue
                border = LineString(
                    [
                        (dic["sbox"][n][0], dic["sbox"][n][1]),
                        (dic["sbox"][n + 1][0], dic["sbox"][n + 1][1]),
                    ]
                )
                if lines[0] == 0:
                    lines[0] = lines[1]
                elif lines[1] == 0:
                    lines[1] = lines[0]
                if lines[0].intersects(border) or lines[1].intersects(border):
                    ijk = dic["rgrid"].get_ijk(global_index=gind)
                    dic["snum"].append(dic["sai"][count])
                    dic[f"rx{p}"].append(dic["rgrid"].get_xyz(active_index=ind)[0])
                    dic[f"ry{p}"].append(dic["rgrid"].get_xyz(active_index=ind)[1])
                    dic[f"rz{p}"].append(dic["rgrid"].get_xyz(active_index=ind)[2])
                    dic[f"ri{p}"].append(ind)
                    dic[f"rf{p}"].append(dic["rfip"][ind])
                    dic[f"rt{p}"].append(dic[f"rz{p}"][-1] - d_z[int(ind)])
                    dic[f"rk{p}"].append(ijk[2])
                    dic["oprn"][gind] = f"{n+2}"
                    check_regional_neighbours(dic, gind, p, n, d_z)
                else:
                    dic["sdel"].append(count)
                    dic[f"sd{p}"].append(i)
            (
                dic[f"sx{p}"],
                dic[f"sy{p}"],
                dic[f"sz{p}"],
                dic[f"sf{p}"],
                dic[f"st{p}"],
            ) = (
                np.array(dic[f"sx{p}"]),
                np.array(dic[f"sy{p}"]),
                np.array(dic[f"sz{p}"]),
                np.array(dic[f"sf{p}"]),
                np.array(dic[f"st{p}"]),
            )
            dic[f"ri{p}"] = np.array(dic[f"ri{p}"])
            dic[f"rx{p}"] = np.array(dic[f"rx{p}"])
            dic[f"ry{p}"] = np.array(dic[f"ry{p}"])
            dic[f"rz{p}"] = np.array(dic[f"rz{p}"])
            dic[f"rf{p}"] = np.array(dic[f"rf{p}"])
            dic[f"rt{p}"] = np.array(dic[f"rt{p}"])
            dic[f"rk{p}"] = np.array(dic[f"rk{p}"])
    for rem in reversed(dic["sdel"]):
        del dic["sbound"][rem]
    git = (
        "--This file was generated by expreccs https://github.com/cssr-tools/expreccs\n"
    )
    dic["oprn"] = compact_format(dic["oprn"])
    dic["oprn"].insert(0, "OPERNUM\n")
    dic["oprn"].insert(0, git)
    dic["oprn"].insert(0, "--Copyright (C) 2025 NORCE Research AS\n")
    dic["oprn"].append("/")
    with open(
        f"{dic['freg']}/OPERNUM_EXPRECCS.INC",
        "w",
        encoding="utf8",
    ) as file:
        file.write("".join(dic["oprn"]))
    dic["fipn"] = compact_format(dic["fipn"])
    dic["fipn"].insert(0, "FIPNUM\n")
    dic["fipn"].insert(0, git)
    dic["fipn"].insert(0, "--Copyright (C) 2025 NORCE Research AS\n")
    dic["fipn"].append("/")
    with open(
        f"{dic['freg']}/FIPNUM_EXPRECCS.INC",
        "w",
        encoding="utf8",
    ) as file:
        file.write("".join(dic["fipn"]))


def dynamic_interpolator(dic):
    """
    Project the pressures from the regional to the site over time

    Args:
        dic (dict): Global dictionary

    Returns:
        dic (dict): Modified global dictionary

    """
    dic["rp"] = [[] for _ in range(dic["rrst"].num_report_steps())]
    for p in ["n", "w", "s", "e"]:
        dic[f"rp{p}"] = [[] for _ in range(dic["rrst"].num_report_steps())]
    print("Dynamic interpolator:")
    with alive_bar(dic["rrst"].num_report_steps()) as bar_animation:
        for i in range(dic["rrst"].num_report_steps()):
            bar_animation()
            project_pressures(dic, i)


def temporal_interpolation(dic):
    """
    Function to interpolate BC pressure values in time

    Args:
        dic (dict): Global dictionary

    Returns:
        dic (dict): Modified global dictionary

    """
    if max(dic["freq"]) > 0:
        dic["ddays"] = dic["sdays"][1:] - dic["sdays"][:-1]
        idays = []
        for i, day in enumerate(dic["sdays"][:-1]):
            for n in range(dic["freq"][i]):
                if dic["acoeff"][i] != 0:
                    telsc = np.flip(
                        (
                            np.exp(
                                np.flip(
                                    np.linspace(0, dic["acoeff"][i], dic["freq"][i] + 1)
                                )
                            )
                            - 1
                        )
                        / (np.exp(dic["acoeff"][i]) - 1)
                    )
                    idays += [day + 1.0 * dic["ddays"][i] * telsc[n]]
                else:
                    idays += [day + 1.0 * dic["ddays"][i] * n / dic["freq"][i]]
        idays += [dic["sdays"][-1]]
        dic["sdays"] = np.array(idays)
        dic["ddays"] = dic["sdays"][1:] - dic["sdays"][:-1]
    else:
        dic["ddays"] = []
    print(f"\nInput report steps regional (days, tot={len(dic['rdays'])}):")
    print(dic["rdays"])
    print(f"Input report steps site (days, tot={len(dic['isdays'])}):")
    print(dic["isdays"])
    print(f"Report steps site to write bc (days, tot={len(dic['sdays'])}):")
    print([float(f"{val:.2f}") for val in dic["sdays"]])
    dic["sbc"] = ["" for _ in range(len(dic["sdays"]))]
    for i in range(len(dic["rp"][0])):
        interp_func = interp1d(
            dic["rdays"],
            [dic["rp"][j][i][1] for j in range(len(dic["rdays"]))],
            fill_value="extrapolate",
        )
        for j, time in enumerate(dic["sdays"]):
            if dic["explicit"]:
                dic["sbc"][
                    j
                ] += f"{dic['rp'][0][i][0]} DIRICHLET WATER 1* {interp_func(time)} /\n"
            else:
                pres = interp_func(time) + dic["spres"][dic["rp"][0][i][0] - 1]
                dic["sbc"][j] += f"{dic['rp'][0][i][0]} DIRICHLET WATER 1* {pres} /\n"


def project_pressures(dic, i):
    """
    Project the pressures at restart number i

    Args:
        dic (dict): Global dictionary\n
        i (int): Index of report step in the site

    Returns:
        dic (dict): Modified global dictionary

    """
    count, c_c, s_s, d_t, whr = 0, 1, 0, 0, 0
    for _, p in enumerate(["n", "w", "s", "e"]):
        n = 0
        if len(dic[f"ri{p}"]) == 0:
            count += len(dic[f"sx{p}"])
            c_c += len(dic[f"sx{p}"]) + s_s
            s_s = 0
            continue
        z_p = np.array(dic["rrst"].iget_kw("PRESSURE")[i])[dic[f"ri{p}"]]
        w_d = np.array(dic["rrst"].iget_kw("WAT_DEN")[i])
        if not dic["explicit"]:
            z_p -= np.array(dic["rrst"].iget_kw("PRESSURE")[0])[dic[f"ri{p}"]]
        if dic["rgrid"].nz > 1:
            if not dic["zones"]:
                interp = LinearNDInterpolator(
                    list(zip(dic[f"rx{p}"], dic[f"ry{p}"], dic[f"rz{p}"])), z_p
                )
            for k, (x, y, z) in enumerate(
                zip(dic[f"sx{p}"], dic[f"sy{p}"], dic[f"sz{p}"])
            ):
                if dic["sai"][count] in dic["snum"]:
                    if dic["zones"]:
                        if dic[f"sf{p}"][k] in dic["ufip"]:
                            if n != dic[f"sf{p}"][k]:
                                n = dic[f"sf{p}"][k]
                                whr = dic[f"rf{p}"] == n
                                if len(np.unique(dic[f"rk{p}"][whr])) == 1:
                                    interp = LinearNDInterpolator(
                                        list(
                                            zip(dic[f"rx{p}"][whr], dic[f"ry{p}"][whr])
                                        ),
                                        z_p[whr],
                                    )
                                else:
                                    whs = dic[f"sf{p}"] == n
                                    d_t = np.round(
                                        min(dic[f"rt{p}"][whr])
                                        - min(dic[f"st{p}"][whs]),
                                        2,
                                    )
                                    interp = LinearNDInterpolator(
                                        list(
                                            zip(
                                                dic[f"rx{p}"][whr],
                                                dic[f"ry{p}"][whr],
                                                dic[f"rz{p}"][whr],
                                            )
                                        ),
                                        z_p[whr],
                                    )
                            if len(np.unique(dic[f"rk{p}"][whr])) == 1:
                                z_b = interp((x, y))
                            else:
                                z_b = interp((x, y, z + d_t))
                                if np.isnan(z_b):
                                    z_b = interp((x, y, dic[f"rkg{p}"][k][0]))
                        else:
                            if i == 0:
                                for j, row in enumerate(dic["sbound"]):
                                    if int(row.split()[0]) == dic["sai"][count] + 1:
                                        dic["sbound"].pop(j)
                                        s_s += 1
                                        continue
                            count += 1
                            continue
                    else:
                        z_b = interp((x, y, z))
                        if np.isnan(z_b):
                            if not dic["explicit"]:
                                z_b = interp((x, y, dic[f"rkg{p}"][k][0]))
                            else:
                                z_b = (
                                    interp((x, y, dic[f"rkg{p}"][k][0]))
                                    + (z - dic[f"rkg{p}"][k][0])
                                    * w_d[dic[f"rkg{p}"][k][1]]
                                    * 9.81
                                    / 1e5
                                )
                    if not np.isnan(z_b):
                        dic["rp"][i].append([dic["sai"][count] + 1, z_b])
                        for j, row in enumerate(dic["sbound"]):
                            edit = row.split()
                            if int(edit[0]) == dic["sai"][count] + 1:
                                if i == 0:
                                    edit[0] = str(dic["sai"][count] + 1)
                                    dic["sbound"][j] = " ".join(edit)
                                    dic["sopn"][
                                        dic["sgrid"].get_global_index(
                                            ijk=(
                                                int(edit[1]) - 1,
                                                int(edit[3]) - 1,
                                                int(edit[5]) - 1,
                                            )
                                        )
                                    ] = "2"
                                c_c += 1
                                continue
                    else:
                        if i == 0:
                            for j, row in enumerate(dic["sbound"]):
                                if int(row.split()[0]) == dic["sai"][count] + 1:
                                    dic["sbound"].pop(j)
                                    s_s += 1
                                    continue
                count += 1
        else:
            interp = LinearNDInterpolator(list(zip(dic[f"rx{p}"], dic[f"ry{p}"])), z_p)
            for x, y in zip(dic[f"sx{p}"], dic[f"sy{p}"]):
                if dic["sai"][count] in dic["snum"]:
                    if not np.isnan(interp((x, y))):
                        dic["rp"][i].append([dic["sai"][count] + 1, interp((x, y))])
                        for j, row in enumerate(dic["sbound"]):
                            edit = row.split()
                            if int(edit[0]) == dic["sai"][count] + 1:
                                if i == 0:
                                    edit[0] = str(c_c + s_s)
                                    dic["sbound"][j] = " ".join(edit)
                                    dic["sopn"][
                                        dic["sgrid"].get_global_index(
                                            ijk=(
                                                int(edit[1]) - 1,
                                                int(edit[3]) - 1,
                                                int(edit[5]) - 1,
                                            )
                                        )
                                    ] = "2"
                                c_c += 1
                                continue
                    else:
                        if i == 0:
                            for j, row in enumerate(dic["sbound"]):
                                if int(row.split()[0]) == dic["sai"][count] + 1:
                                    dic["sbound"].pop(j)
                                    s_s += 1
                                    continue
                count += 1


def write_files(dic):
    """
    Write the files with the projected pressures

    Args:
        dic (dict): Global dictionary

    Returns:
        dic (dict): Modified global dictionary

    """
    if dic["fsit"] != dic["fol"]:
        dic["files"] = [f for f in os.listdir(f"{dic['fsit']}") if f.endswith(".INC")]
        for file in dic["files"]:
            os.system(f"scp -r {dic['fsit']}/{file} {dic['fol']}")
    fre, tstep, count, lol = 0, 0, 1, []
    with open(dic["sdata"], "r", encoding="utf8") as file:
        for row in csv.reader(file):
            nrwo = str(row)[2:-2]
            if 0 < nrwo.find("\\t"):
                nrwo = nrwo.replace("\\t", " ")
            lol.append(nrwo)
            if lol[-1] == "GRID" and max(dic["freq"]) > 0:
                lol.append("INCLUDE")
                lol.append("'BCCON.INC' /")
            if lol[-1] == "REGIONS":
                lol.append("INCLUDE")
                lol.append("'OPERNUM_EXPRECCS.INC' /")
    with open(
        f"{dic['fol']}/{dic['fol'].split('/')[-1].upper()}.DATA",
        "w",
        encoding="utf8",
    ) as file:
        for i, row in enumerate(lol):
            edit = row.split()
            if i < len(lol) - 1:
                if lol[i + 1] == "TSTEP" and max(dic["freq"]) > 0:
                    rep = lol[i + 2].split("*")
                    rep = int(rep[0]) if len(rep) > 1 else 1
                    file.write(row)
                    file.write("\n")
                    for _ in range(rep):
                        for _ in range(dic["freq"][fre]):
                            file.write("INCLUDE\n")
                            file.write(f"'bc/BCPROP{count}.INC' /\n")
                            file.write("TSTEP\n")
                            file.write(f"{dic['ddays'][count-1]} /\n")
                            count += 1
                            tstep = 1
                        fre += 1
                elif tstep == 0:
                    file.write(row)
                    file.write("\n")
                elif edit and tstep == 1:
                    if edit[-1] == "/" or edit[0] == "/":
                        tstep = 0
            else:
                if tstep == 0:
                    file.write(row)
    git = "--This file was generated by expreccs https://github.com/cssr-tools/expreccs"
    if max(dic["freq"]) > 0:
        dic["sbound"].insert(0, "BCCON")
        dic["sbound"].insert(0, git)
        dic["sbound"].insert(0, "--Copyright (C) 2025 NORCE Research AS")
        dic["sbound"].append("/")
        with open(
            f"{dic['fol']}/BCCON.INC",
            "w",
            encoding="utf8",
        ) as file:
            file.write("\n".join(dic["sbound"]))
        for i in range(len(dic["sdays"])):
            dic["sbc"][i] = [dic["sbc"][i]]
            dic["sbc"][i].insert(0, "BCPROP\n")
            dic["sbc"][i].insert(0, f"--No. days = {dic['sdays'][i]:.2f}\n")
            dic["sbc"][i].insert(0, git + "\n")
            dic["sbc"][i].insert(0, "--Copyright (C) 2025 NORCE Research AS\n")
            dic["sbc"][i].append("/")
            with open(
                f"{dic['fol']}/bc/BCPROP{i}.INC",
                "w",
                encoding="utf8",
            ) as file:
                file.write("".join(dic["sbc"][i]))
    dic["sopn"] = compact_format(dic["sopn"])
    dic["sopn"].insert(0, "OPERNUM\n")
    dic["sopn"].insert(0, git + "\n")
    dic["sopn"].insert(0, "--Copyright (C) 2025 NORCE Research AS\n")
    dic["sopn"].append("/")
    with open(
        f"{dic['fol']}/OPERNUM_EXPRECCS.INC",
        "w",
        encoding="utf8",
    ) as file:
        file.write("".join(dic["sopn"]))


def find_ij_orientation(dic):
    """
    Find if the counting is left/right handed

    Args:
        dic (dict): Global dictionary

    Returns:
        dic (dict): Modified global dictionary

    """
    y1 = dic["sgrid"].get_xyz(ijk=(0, 0, 0))[1]
    y2 = dic["sgrid"].get_xyz(ijk=(0, 1, 0))[1]
    x1 = dic["sgrid"].get_xyz(ijk=(0, 0, 0))[1]
    x2 = dic["sgrid"].get_xyz(ijk=(1, 0, 0))[1]
    if y2 < y1:
        dic["mly"] = 1
    else:
        dic["mly"] = -1
    if x2 < x1:
        dic["mlx"] = 1
    else:
        dic["mlx"] = -1


def extract_site_borders(dic):
    """
    Get the index/coord from the site border

    Args:
        dic (dict): Global dictionary

    Returns:
        dic (dict): Modified global dictionary

    """
    dic["spres"] = []
    d_z = 0.5 * dic["sinit"].iget_kw("DZ")[0]
    if dic["boundaries"][0] > -1:
        for k in range(dic["sgrid"].nz):
            j = dic["boundaries"][0]
            for i in range(dic["sgrid"].nx):
                ind = dic["sgrid"].get_active_index(ijk=(i, j, k))
                if dic["sgrid"].active(ijk=(i, j, k)):
                    dic["sai"].append(dic["gc"])
                    xyz = np.array(dic["sgrid"].get_xyz(ijk=(i, j, k)))
                    d_y = 0.5 * dic["sinit"].iget_kw("DY")[0][ind]
                    dic["sbound"].append(
                        f"{dic['gc'] + 1} {i + 1} {i + 1} {j + 1} {j + 1} {k + 1} {k + 1} 'J-' /"
                    )
                    dic["sxn"].append(xyz[0])
                    dic["syn"].append(xyz[1] + dic["mly"] * d_y)
                    dic["szn"].append(xyz[2])
                    dic["sfn"].append(dic["sfip"][ind])
                    dic["stn"].append(xyz[2] - d_z[ind])
                if not dic["explicit"]:
                    dic["spres"].append(dic["srst"].iget_kw("PRESSURE")[0][ind])
                dic["gc"] += 1
    if dic["boundaries"][1] > -1:
        for k in range(dic["sgrid"].nz):
            i = dic["sgrid"].nx - 1 - dic["boundaries"][1]
            for j in range(dic["sgrid"].ny):
                ind = dic["sgrid"].get_active_index(ijk=(i, j, k))
                if dic["sgrid"].active(ijk=(i, j, k)):
                    dic["sai"].append(dic["gc"])
                    xyz = np.array(dic["sgrid"].get_xyz(ijk=(i, j, k)))
                    d_x = 0.5 * dic["sinit"].iget_kw("DX")[0][ind]
                    dic["sbound"].append(
                        f"{dic['gc'] + 1} {i + 1} {i + 1} {j + 1} {j + 1} {k + 1} {k + 1} 'I' /"
                    )
                    dic["sxw"].append(xyz[0] + dic["mlx"] * d_x * (-1))
                    dic["syw"].append(xyz[1])
                    dic["szw"].append(xyz[2])
                    dic["sfw"].append(dic["sfip"][ind])
                    dic["stw"].append(xyz[2] - d_z[ind])
                if not dic["explicit"]:
                    dic["spres"].append(dic["srst"].iget_kw("PRESSURE")[0][ind])
                dic["gc"] += 1
    if dic["boundaries"][2] > -1:
        for k in range(dic["sgrid"].nz):
            j = dic["sgrid"].ny - 1 - dic["boundaries"][2]
            for i in range(dic["sgrid"].nx):
                ii = dic["sgrid"].nx - i - 1
                ind = dic["sgrid"].get_active_index(ijk=(ii, j, k))
                if dic["sgrid"].active(ijk=(ii, j, k)):
                    dic["sai"].append(dic["gc"])
                    xyz = np.array(dic["sgrid"].get_xyz(ijk=(ii, j, k)))
                    d_y = 0.5 * dic["sinit"].iget_kw("DY")[0][ind]
                    dic["sbound"].append(
                        f"{dic['gc'] + 1} {ii + 1} {ii + 1} {j + 1} {j + 1} {k + 1} {k + 1} 'J' /"
                    )
                    dic["sxs"].append(xyz[0])
                    dic["sys"].append(xyz[1] + dic["mly"] * d_y * (-1))
                    dic["szs"].append(xyz[2])
                    dic["sfs"].append(dic["sfip"][ind])
                    dic["sts"].append(xyz[2] - d_z[ind])
                if not dic["explicit"]:
                    dic["spres"].append(dic["srst"].iget_kw("PRESSURE")[0][ind])
                dic["gc"] += 1
    if dic["boundaries"][3] > -1:
        for k in range(dic["sgrid"].nz):
            i = dic["boundaries"][3]
            for j in range(dic["sgrid"].ny):
                jj = dic["sgrid"].ny - j - 1
                ind = dic["sgrid"].get_active_index(ijk=(i, jj, k))
                if dic["sgrid"].active(ijk=(i, jj, k)):
                    dic["sai"].append(dic["gc"])
                    xyz = np.array(dic["sgrid"].get_xyz(ijk=(i, jj, k)))
                    d_x = 0.5 * dic["sinit"].iget_kw("DX")[0][ind]
                    dic["sbound"].append(
                        f"{dic['gc'] + 1} {i + 1} {i + 1} {jj + 1} {jj + 1} {k + 1} {k + 1} 'I-' /"
                    )
                    dic["sxe"].append(xyz[0] + dic["mlx"] * d_x)
                    dic["sye"].append(xyz[1])
                    dic["sze"].append(xyz[2])
                    dic["sfe"].append(dic["sfip"][ind])
                    dic["ste"].append(xyz[2] - d_z[ind])
                if not dic["explicit"]:
                    dic["spres"].append(dic["srst"].iget_kw("PRESSURE")[0][ind])
                dic["gc"] += 1
